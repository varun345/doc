---
description: Migrate to new DUTY Syrup Pool
---

# DUTY Syrup Pool

The new DutyPool is a new $DUTY staking contract built based on the DutyVault (the current auto DUTY pool) and designed to work with DutySwap MasterChef v2 to provide "stake $DUTY, earn $DUTY" functionality while offering more features such as fixed-term staking. The current Manual DUTY pool will be retired after the migration.

The new DutyPool will use a dummy token to harvest $DUTY from MasterChef v2 and reward them to users who are staking $DUTY. Users who lock their $DUTY for longer will receive a more significant number of shares (boosted linearly based on duration), therefore, enjoy a higher yield.

### Do I need to migrate?&#x20;

If you are currently using `enterStaking` and `leaveStaking` on the DutySwap MasterChef ([0x73feaa1eE314F8c655E354234017bE2193C9E24E](https://bscscan.com/address/0x73feaa1eE314F8c655E354234017bE2193C9E24E)), you will need to migrate to the new contract.

### No more compounding

With the new DutyPool, rewards are distributed proportionally to all pool users based on shares. Similar to “interest-bearing tokens” or other share-based models, users’ staking balance will grow when more rewards are being put into the pool. Users don’t need to harvest and compound their rewards.

### Fees&#x20;

In the new DutyPool, all flexible staking users will be subjected to two sets of fees.&#x20;

#### Fee on flexible staking rewards&#x20;

A 2% fee will apply to all the rewards generated by flexible staking. The amount of the fee will be calculated and realized upon the next deposit or withdrawal action, cut from users’ shares. To query the number of the unrealized performance fee, use `calculatePerformanceFee(address _user)`.&#x20;

#### Withdrawal fee&#x20;

A 0.1% withdrawal fee will apply to the unstaking amount if you withdraw within 72 hours of the last deposit action. The withdrawal fee is cut from the final withdrawal amount before the DUTY transfer.

### Overview

#### Deposit

If you are currently using the `enterStaking(uint256 _amount)` on the current DutySwap MasterChef. You need to migrate to `deposit(uint256 _amount, uint256 _lockDuration)`. For flexible staking, simply use “0” as `_lockDuration`.

#### Staking Balance and Fees

```
Global variables: DutyPoolContract // DUTY pool contract
struct UserInfo {
    uint256 shares; // number of shares for a user.
    uint256 lastDepositedTime; // timestamp of the last deposit action
    uint256 dutyAtLastUserAction; // number of DUTY at the last user action
    uint256 lastUserActionTime; // timestamp of the last user action
    uint256 lockStartTime; // timestamp of the start of the lock.
    uint256 lockEndTime; // timestamp of the end of the lock.
    uint256 userBoostedShare; // the amount of shares boosted/added to the user.
    bool locked; // status of the lock
    uint256 lockedAmount; // number of DUTY locked at the start of the lock period.
}
```

**DUTY staking amount (before subtracting all the fees)**

```
const userInfo. = await DutyPoolContract.userInfo(address);
const PricePerFullShare = await DutyPoolContract.getPricePerFullShare();
const dutyAmount = userInfo.shares * PricePerFullShare / 1e18 - userInfo.userBoostedShare ;  // duty amount (wei), in flexible staking, userInfo.userBoostedShare should be 0.
```

**Performance Fee**

Query from contract:

```
const performanceFeeAmount = await DutyPoolContract.calculatePerformanceFee(address);
```

Calculate it manually:

```
async function calculatePerformanceFeeAmount(_user:address){
    const user = await DutyPoolContract.userInfo(address);
    const isFreeFee = await DutyPoolContract.freeFeeUsers(_user);  //normal free fee users are some special contracts , so you can set default false

    if(user.shares > 0 && !user.locked && !isFreeFee){
        const PricePerFullShare = await DutyPoolContract.getPricePerFullShare();
        uint256 totalAmount = user.shares * PricePerFullShare / 1e18; 
        uint256 earnAmount = totalAmount - user.dutyAtLastUserAction;
        uint256 performanceFee = await  DutyPoolContract.performanceFee();
        uint256 currentPerformanceFee = (earnAmount * performanceFee) / 10000;
        return currentPerformanceFee;
    }
    return 0;
}
```

**Overdue Fee: (only applies to locked staking)**

Query from contract:

```
const overdueFeeAmount = await DutyPoolContract.calculateOverdueFee(address);
```

Calculate it manually:

```
async function calculateOverdueFee(_user:address){
    const user = await DutyPoolContract.userInfo(address);
    const isFreeFee = await DutyPoolContract.freeFeeUsers(_user); //normal free fee users are some special contracts , so you can set default false
    const UNLOCK_FREE_DURATION = 1 week seconds (or you can get from smart contract,  const UNLOCK_FREE_DURATION = await DutyPoolContract.UNLOCK_FREE_DURATION())
    const DURATION_FACTOR_OVERDUE = 180 * 24 * 3600; // 180 days, in order to calculate overdue fee. you can get it from contract too.

    if (
        user.shares > 0 &&
        user.locked &&
        !isFreeFee &&
        ((user.lockEndTime + UNLOCK_FREE_DURATION) < block.timestamp)
    ) {
        const PricePerFullShare = await DutyPoolContract.getPricePerFullShare();
        uint256 currentAmount = user.shares * PricePerFullShare / 1e18 - user.userBoostedShare;
        uint256 earnAmount = currentAmount - user.lockedAmount;
        uint256 overdueDuration = block.timestamp - user.lockEndTime - UNLOCK_FREE_DURATION;  //  you can use UTC timestamp to replace current block.timestamp.
        if (overdueDuration > DURATION_FACTOR_OVERDUE) {
            overdueDuration = DURATION_FACTOR_OVERDUE;
        }
        // Rates are calculated based on the user's overdue duration.
        uint256 overdueWeight = (overdueDuration * overdueFee) / DURATION_FACTOR_OVERDUE;
        uint256 currentOverdueFee = (earnAmount * overdueWeight) / PRECISION_FACTOR;
        return currentOverdueFee;
    }
    return 0;
}
```

**Withdraw Fee**

```
const user = await DutyPoolContract.userInfo(address);
const withdrawFee = await  DutyPoolContract.withdrawFee();
const isFreeFee = await DutyPoolContract.freeFeeUsers(_user); //normal free fee users are some special contracts , so you can set default false
let WithdrawFeeAmount = 0;
// you can use UTC timestamp to replace current block.timestamp.
// withdrawFeePeriod = 72 * 3600 (S)
// _amount : withdraw amount
if (!isFreeFee && (block.timestamp < user.lastDepositedTime + withdrawFeePeriod)) {
     WithdrawFeeAmount = _amount * withdrawFee;
}
```

**DUTY staking amount (after subtracting all the fees)**

```
const user = await DutyPoolContract.userInfo(address);
const dutyAmountWithoutFee =  dutyAmount - (!user.locked ? performanceFeeAmount : overdueFeeAmount) - withdrawFeeAmount
```

#### Pending Rewards&#x20;

Please note that the new pool does not require any compounding. Rewards are being put into your staking balance automatically.

However, you can query the number of DUTY earned since the last action, using the difference between the current staking balance (mentioned above), and the number from `userInfo.dutyAtLastUserAction`.

#### Withdraw

If you are using the `leaveStaking(uint256 _amount)` method on the current DutySwap MasterChef. You need to migrate to `withdraw(uint256 _shares)`.

When doing flexible staking. Please note that upon withdrawing, the pending reward fees will be calculated and cut from the number of users’ shares, the actual number of shares being withdrawn will be re-calibrated, based on the percentage of the shares you are withdrawing against the total shares you have. See the example below:

```
// the number of DUTY being withdrawn can be calculated by:
withdrawPercentage = _sharesToWithdraw / userInfo.shares
stakingBalance = userInfo.shares * PricePerFullShare / 1e18 - userInfo.userBoostedShare - !userInfo.locked ? calculatePerformanceFee(_userAddress) : calculateOverdueFee(_userAddress)
finalWithdrawAmount = withdrawPercentage * stakingBalance
```

Please note that the final receiving amount will be affected by withdraw fee. If your function relies crucially on the final number of DUTY being withdrawn, we recommend calculating that using the difference in DUTY balance before and after the withdrawal action:

```
dutyBalPrev = DUTY.balanceOf(address(this))
DutyPool.withdraw(_sharesToWithdraw)
dutyBalNew = DUTY.balanceOf(address(this))
dutyWithdrawn = dutyBalNew - dutyBalPrev
```

Or, calculate and subtract the withdraw fee when estimating the amount.

#### How to calculate the DUTY per block distributed to the new DUTY pool?

Previously, the manual DUTY pool had a fixed 10 DUTY/block emission. After migrating to MasterChef v2 and the new DUTY pool, we can now adjust its emissions.

And here's how you can calculate the DUTY per block distributed to the new DUTY pool:

`dutyPerBlockToPool = MasterChef.dutyPerBlock(false) * (dutyPool.allocPoint / MasterChef.totalSpecialAllocPoint)`

You can query the `dutyPool.allocPoint` using `MasterChef.poolInfo(0)`

### **Mainnet Contract Address**

**Contract name:** DutyPool\
**Contract address:** `0x45c54210128a065de780C4B0Df3d16664f7f859e`

[View the DutySwap: Duty Pool Contract on BscScan.](https://bscscan.com/address/0x45c54210128a065de780C4B0Df3d16664f7f859e)****

### **Testnet Environment**

You can use the following testnet environment to test the integration of your project with the new DutySwap DUTY Pool. If you have any questions, please contact our team via the existing channels, or reach out to bun@dutyswap.com via Email.

**Dummy Tokens:**

* $DUTY: `0xFa60D973F7642B748046464e165A65B7323b0DEE`\
  (mintable by using `mint(address _to, uint256 _amount) public`)
* $WBNB: `0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd`

#### Factory and Router

* Factory v2: `0x6725F303b657a9451d8BA641348b6761A6CC7a17`
* Router v2: `0xD99D1c33F9fC3444f8101754aBC46c52416550D1`

#### MasterChefs

* v1: `0x1ED62c7b76AD29Bfb80F3329d1ce7e760aAD153d`
  * pid0: Manual DUTY
  * pid4: Dummy Pool for MasterChef v2
* v2: `0xB4A466911556e39210a6bB2FaECBB59E4eB7E43d`

#### New DUTY Pool

`0x683433ba14e8F26774D43D3E90DA6Dd7a22044Fe`
